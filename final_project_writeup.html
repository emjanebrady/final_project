<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emma Brady (GitHub: @emjanebrady; Section: 3)">
<meta name="dcterms.date" content="2024-12-04">

<title>Final Project Write-Up</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="final_project_writeup_files/libs/clipboard/clipboard.min.js"></script>
<script src="final_project_writeup_files/libs/quarto-html/quarto.js"></script>
<script src="final_project_writeup_files/libs/quarto-html/popper.min.js"></script>
<script src="final_project_writeup_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="final_project_writeup_files/libs/quarto-html/anchor.min.js"></script>
<link href="final_project_writeup_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="final_project_writeup_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="final_project_writeup_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="final_project_writeup_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="final_project_writeup_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Project Write-Up</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Emma Brady (GitHub: <span class="citation" data-cites="emjanebrady">@emjanebrady</span>; Section: 3) </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 4, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="data" class="level1">
<h1>Data</h1>
<p>For my project, I am interested in looking at the relationship between education and recidivism rates. One of the major challenges of the prison complex is that individuals are rarely arrested just once–within one year, 43% of formerly incarcerated individuals are rearrested and within 10 years, 82% are rearrested at least once (<a href="https://bjs.ojp.gov/sites/g/files/xyckuh236/files/media/document/rpr24s0810yfup0818_sum.pdf">Recidivism of Prisoners Released in 24 States in 2008: A 10-Year Follow-Up Period (2008-2018), Bureau of Justice Statistics</a>). There are numerous factors contributing to this issue, such as lack of resources out of prison, including jobs and housing, substance use, and the inability to leave negative living situations. A key policy issue today is determining what policies we can enact to reduce recidivism rates.</p>
<p>One possible solution to reduce recidivism is improving education. Research shows that inmates who participate in correctional education programs have 43 percent lower odds of returning to prison than those who do not, and that every dollar spent on prison education saves four to five dollars on the costs of re-incarceration. (<a href="https://www.bja.gov/Publications/RAND_Correctional-Education-Meta-Analysis.pdf">Education and Vocational Training in Prisons Reduces Recidivism, Improves Job Outlook, Rand Corporation</a>)</p>
<p>To start, I want to create some graphs to visualize the relationship between education levels, behavior in school, and recidivism. This is simply a preliminary step to see if there is a relationship there, this is not a quantitative test or experiment to see if there is a causal relationship between the two.</p>
<p>I will be using two datasets. The first looks at prison in general and the second looks at juvenile deliquency. I chose these two as we can see the long-term effects of education through the first dataset and the connection between current behavior in school and juvenile delinquency in the second.</p>
<p>The first comes from the NIJ Recidivism Challange, in which the National Institute of Justice released the data on roughly 26,000 individuals from the State of Georgia released from Georgia prisons on discretionary parole to the custody of the Georgia Department of Community Supervision (GDCS) for the purpose of post-incarceration supervision between January 1, 2013 and December 31, 2015. This data was released publicly to challenge analysists to predict recividism based on the demographic information provided, including education level.</p>
<p>The second dataset comes from a state-wide sample of Florida juveniles who completed probation supervision between 2015 and 2018. The study the dataset comes from examines trajectories of risk and protective factors throughout probation supervision, whether such trajectories affect the likelihood of recidivism, and how community context influences those relationships.</p>
</section>
<section id="examination-of-data" class="level1">
<h1>Examination of Data</h1>
<section id="dataset-1" class="level2">
<h2 class="anchored" data-anchor-id="dataset-1">Dataset #1</h2>
<p>I first started examining the NIJ dataset by taking a look at null values. I wanted to see where null values in the dataset where and how I should treat them when I began analysis.</p>
<p><img src="./null_chart.png"></p>
<p>From this bar chart we can see that approximately 1/5 of the data around drug tests is N/A, including ‘Avg_Days_per_DrugTest’, ‘DrugTests_Cocaine_Positive’, ‘DrugTests_Meth_Positive’, ‘DrugTests_Other_Positive’, and ‘DrugTests_THC_Positive’. This is good to know moving forward with the data analysis. If I run any analysis with these variables, I will not include the NA variables.</p>
<p>Next, I looked at the relationship between education level and the recidivism rate within 3 years.</p>
<p><img src="./education_level_bar.png"></p>
<p>From the normalized bar chart, we can see that there isn’t a difference in the recidivism rate between those who have a high school diploma and those who don’t. This indicates that we should explore those variables more, because it is strange for them to be equal. But we can also see that those with at least some college have approximately a 12% lower recividism rate within 3 years than those with a high school diploma or less than a high school diploma. This does not necessarily mean that college itself causes lower rates of recidivism–this is not an RCT and there could be self-selection factors that leads to those with some college going back to prison at lower rates. But this preliminary chart does give us reason to examine the relationship between education and recidivism closer.</p>
<p>For the final chart for this dataset, I looked at education levels in the dataset broken down by race. This dataset only includes Black and White as races. This could be a red flag for the dataset, but is likely because this dataset as a challenge for analysts and kept several identitying features out.</p>
<p><img src="./race_bar.png"></p>
<p>This graph is helpful in visualizing the difference in race and education. From this we can see that those who are Black have slighlty higher rates of not having a high school diploma than those who are White in prison. As we further analyze the relationship between education and race, we should be aware of the differences between race.</p>
</section>
<section id="dataset-2" class="level2">
<h2 class="anchored" data-anchor-id="dataset-2">Dataset #2</h2>
<p>The next dataset I used for analysis in my shiny app. Below are descriptions of the varaibles I used.</p>
<p>In the dataset, three separate measures of recidivism were used to allow for more robust findings: rearrest, readjudication, and placement. Rearrest meant arrest for a new offense within 365 days of the date the youth completed their community-based disposition. Readjudication was measured according to the official definition of recidivism for the FDJJ as an adjudication or adult conviction for an offense that occurred within 365 days of the youth completing the community-based disposition. Placement included assignment of a youth to a juvenile justice residential facility or adult prison for an offense that occurred within 365 days of the youth completing community-based dispositions.</p>
<p>The measures for school status are as follows–a binary measure of those who are enrolled in high school, those who have dropped out of school, and those who have received their high school diploma/GED. Although the measures for enrolled and dropped out of high school appear to measure the same thing, there is some difference in the individuals they capture–19.7% of the sample is not enrolled in school, while only 15.1% have dropped out. Additional measures of school status are recent school conduct, recent school attendance, and recent academic performance, each ranging in values between 1-5, with one indicating exemplary behavior and 5 indicating concerning behavior.</p>
</section>
<section id="shiny-app" class="level2">
<h2 class="anchored" data-anchor-id="shiny-app">Shiny App</h2>
<p>For the shiny app, I created dynamic plots measuring the education measures against the recivdivism measures in the juvenile dataset. Through this app, we can get a better idea of which education measures seem to have the highest correlation with recidivism.</p>
<p>Overall, the recividism measure rearrested within 1 year has a stronger correlation with the education measures than readjudicated within 1 year or placement/incarceration within 1 year. This could be due to the fact that there are higher rates of rearrest (51.6%) than redjudication (35.9%) or replacement (10.5%). Also, we can see with each graph that problems in school are correlated to a higher rate of recidivism.</p>
</section>
</section>
<section id="future-research" class="level1">
<h1>Future Research</h1>
<p>We can see from this preliminary look at this data that there does appear to be a connection between education and recidivism. Whether that is because education itself contributes to lower rates of recidivism or there is overlap in those who perform well in school and those with lower recidivism rates is unclear from the work I have done so far. Further research, including RCTs, will be needed to see how education affects recidivism. In the future research, researchers should also keep in mind how other demographics come into play, including race and income.</p>
<p>It is also crucial for future research and policy design to account for a broad range of demographic factors. For instance, if Black individuals in prison have lower rates of high school diploma attainment compared to their White counterparts, prioritizing college programs over GED programs could inadvertently exclude those who need foundational education support.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>